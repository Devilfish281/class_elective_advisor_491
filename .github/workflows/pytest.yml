# .github/workflows/pytest.yml
# Purpose: Run the project's Python test suite on every push and pull request.
# Why: Catch regressions early, enforce a green main branch, and give reviewers confidence in PRs.

name: Pytest

on:
  push: # Run on any push (all branches) to validate commits before/after merging.
  pull_request: # Run on PRs so reviewers see pass/fail status before approval.

# Prevent duplicate runs on the same ref (e.g., push + PR for the same branch).
# Keeps the most recent run and cancels any in-progress older ones.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Principle of least privilege: tests only need read access to the repo contents.
permissions:
  contents: read

jobs:
  tests:
    runs-on: ubuntu-latest # Fast, predictable, and free Linux runner with Python preinstalled.
    strategy:
      fail-fast: false # If you later add more Python versions, one failure won't cancel others.
      matrix:
        python-version: ["3.12"] # Pin CI to the same Python you use locally for reproducibility.

    steps:
      # 1) Fetch the repository code so we can build and test it.
      - name: Checkout
        uses: actions/checkout@v4

      # 2) Install the exact Python version from the matrix.
      # Why: Avoids "works on my machine" issues due to version mismatches.
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      # 3) Install Poetry (project's package/venv manager).
      # Why: Keep dependency management consistent with local dev (no raw pip).
      - name: Install Poetry
        run: |
          python -m pip install --upgrade pip
          pip install poetry

      # 4) Create the virtualenv inside the project (.venv) for deterministic paths and easy caching.
      # Why: Caching .venv across runs dramatically speeds up CI.
      - name: Enable in-project virtualenv (.venv)
        run: |
          poetry config virtualenvs.in-project true
          poetry --version
          python --version

      # 5) Cache the Poetry virtual environment.
      # Keyed by OS, Python version, and the lockfile hash so cache invalidates on dependency changes.
      - name: Cache virtualenv
        id: cache-venv
        uses: actions/cache@v4
        with:
          path: .venv
          key: venv-${{ runner.os }}-py${{ matrix.python-version }}-${{ hashFiles('poetry.lock') }}
          restore-keys: |
            venv-${{ runner.os }}-py${{ matrix.python-version }}-

      # 6) Install project dependencies using Poetry.
      # --no-interaction / --no-ansi keeps logs clean and non-interactive for CI.
      - name: Install dependencies
        run: |
          poetry install --no-interaction --no-ansi

      # 7) Run the tests.
      # -q              : quieter output for cleaner CI logs
      # --maxfail=1     : fail fast on first failure to save CI minutes
      # OPENAI_API_KEY  : provided via GitHub Actions secret so tests depending on it can run
      # Notes:
      # * If some UI tests require a display, make them headless-safe or skip when $DISPLAY is missing.
      # * Define the secret in GitHub: Settings → Secrets and variables → Actions → New repository secret.
      - name: Run tests
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }} # Set this in repo settings if needed by tests
        run: |
          poetry run pytest -q --maxfail=1
