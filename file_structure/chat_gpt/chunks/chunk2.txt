alt()
            ).decode("utf-8")

            cursor.execute(
                "UPDATE users SET password_hash = ? WHERE email = ?",
                (new_hash, current_user["email"]),
            )
            conn.commit()
            conn.close()

            messagebox.showinfo(
                "Success", "Password changed successfully!", parent=password_window
            )
            logger.info(f"User '{current_user['email']}' changed password.")
            password_window.destroy()

        save_password_button = ttk.Button(
            password_window, text="Save Password", command=perform_password_change
        )
        save_password_button.pack(pady=20)

    change_password_button = ttk.Button(
        settings_frame, text="Change Password", command=change_password
    )
    change_password_button.pack(pady=10, padx=10, fill="x")


def show_help(frame):
    """Display the Help Page"""
    logger.info("Displaying Help Page")
    clear_content(frame)
    set_active_button("Help")

    header_label = ttk.Label(frame, text="Help & Support", font=("Helvetica", 20))
    header_label.pack(pady=20)

    help_frame = ttk.Frame(frame)
    help_frame.pack(pady=10, padx=20, fill="both", expand=True)

    help_text = (
        "Welcome to the Smart Elective Advisor Help Center!\n\n"
        "If you need help navigating the application or have any questions, we've got you covered.\n\n"
        "1. Use Guides: Detailed manuals to help you explore and make the most of the application's features\n\n"
        "2. FAQs: Quick answers to the most common questions from other users.\n\n"
        "3. Contact Support: Need personalized help? Reach out to our support team at support@university.edu\n\n"
    )
    help_label = ttk.Label(
        help_frame,
        text=help_text,
        font=("Helvetica", 14),
        wraplength=800,
        justify="left",
    )
    help_label.pack(pady=10)

    search_label = ttk.Label(
        help_frame, text="Search Help Topics:", font=("Helvetica", 12)
    )
    search_label.pack(pady=5, anchor="w")
    search_entry = ttk.Entry(help_frame, width=50)
    search_entry.pack(pady=5, anchor="w")

    def search_help():
        query = search_entry.get()
        messagebox.showinfo("Coming soon", "coming soon")

    search_button = ttk.Button(help_frame, text="Search", command=search_help)
    search_button.pack(pady=5, anchor="w")

    help_frame.pack_propagate(False)
    spacer = ttk.Frame(help_frame)
    spacer.pack(fill="both", expand=True)
    about_button = ttk.Button(
        help_frame,
        text="About",
        command=lambda: show_about_dialog(frame),
    )
    about_button.pack(pady=10, anchor="e")


def main_test_ui(option: int) -> bool:
    """
    UI test dispatcher:
      option 1 -> launch the real GUI (blocking; user must close window)
      option 2 -> sanity create/destroy root without entering mainloop (fast)
      option 3 -> launch GUI and auto-close after 1 second (useful for CI)
    Returns True on success, False on failure.
    """
    logger.info("main_test_ui: selected option %s", option)

    if option == 1:
        try:
            main_int_ui()
            return True
        except Exception:
            logger.exception("main_test_ui option 1 failed")
            return False

    elif option == 2:
        try:
            root = tk.Tk()
            root.update_idletasks()
            root.destroy()
            logger.info("main_test_ui option 2: sanity create/destroy succeeded")
            return True
        except Exception:
            logger.exception("main_test_ui option 2 failed")
            return False

    elif option == 3:
        try:
            def _run_and_close():
                root = tk.Tk()
                root.title("Smart Elective Advisor (auto-close test)")
                label = tk.Label(root, text="Auto-close test (1s)")
                label.pack(padx=10, pady=10)
                root.after(1000, root.destroy)
                try:
                    root.mainloop()
                except Exception:
                    logger.exception("Exception in auto-close GUI thread")

            t = threading.Thread(target=_run_and_close, daemon=True)
            t.start()
            time.sleep(1.5)
            logger.info("main_test_ui option 3: auto-close GUI test completed")
            return True
        except Exception:
            logger.exception("main_test_ui option 3 failed")
            return False

    else:
        logger.error("main_test_ui: unknown option %s", option)
        return False


if __name__ == "__main__":
    main_test_ui(1)```

########################################
Here is my code for zulu_timestamp.py BELOW:
########################################

```python
# ui/zulu_timestamp.py

from datetime import datetime


def iso_zulu_to_json_parts(ts: str) -> dict:
    """
    Parse an ISO-8601 UTC ('Z') timestamp like 'YYYY-MM-DDTHH:MM:SSZ'
    and return a dict of each component using only the Python stdlib.
    """
    norm = ts.replace("Z", "+00:00")
    dt = datetime.fromisoformat(norm)

    year = f"{dt.year:04d}"
    month = f"{dt.month:02d}"
    day = f"{dt.day:02d}"
    hour = f"{dt.hour:02d}"
    minute = f"{dt.minute:02d}"
    second = f"{dt.second:02d}"

    offset = dt.utcoffset()
    if offset is None:
        utc_offset = "+00:00"
    else:
        total_minutes = int(offset.total_seconds() // 60)
        sign = "+" if total_minutes >= 0 else "-"
        total_minutes = abs(total_minutes)
        utc_offset = f"{sign}{total_minutes // 60:02d}:{total_minutes % 60:02d}"

    return {
        "original": ts,
        "date": f"{year}-{month}-{day}",
        "year": year,
        "month": month,
        "day": day,
        "iso8601_separator": "T",
        "time_UTC": f"{hour}:{minute}:{second}",
        "hour": hour,
        "minute": minute,
        "second": second,
        "timezone_designator": "Z" if ts.endswith("Z") else "",
        "utc_offset": utc_offset,
    }```

########################################
Here is my code for __init__.py BELOW:
########################################

```python
```

########################################
Here is my code for load_env.py BELOW:
########################################

```python
# utilities/load_env.py

import logging
import os
import re
from pathlib import Path
from typing import Optional

from dotenv import find_dotenv, load_dotenv

logger = logging.getLogger(__name__)


def _validate_api_key(key: str) -> bool:
    """
    Conservative validation for the OpenAI API key:
    - must be at least 20 characters (adjust to your provider's expected length)
    - contains at least one alphanumeric character
    """
    if not key:
        return False
    if len(key) < 20:
        return False
    if not re.search(r"[A-Za-z0-9]", key):
        return False
    return True


def load_environment() -> None:
    """
    Load environment variables from .env (if present) and validate required vars.
    Raises ValueError on missing/invalid critical variables.
    """
    logger.info("Loading environment variables.")

    env_path = find_dotenv()
    if env_path:
        load_dotenv(env_path, override=False)
        logger.debug("Loaded .env from %s", env_path)
    else:
        logger.debug(
            ".env file not found; continuing with existing environment variables"
        )

    apikey = os.getenv("OPENAI_API_KEY")
    if not _validate_api_key(apikey or ""):
        logger.error("OPENAI_API_KEY is missing or invalid")
        raise ValueError("OPENAI_API_KEY environment variable missing or invalid")

    logger.info("API Key loaded successfully.")```

########################################
Here is my code for logger_setup.py BELOW:
########################################

```python
# utilities/logger_setup.py

import logging



def setup_logger():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(asctime)s %(levelname)s %(name)s:%(lineno)d %(message)s",
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler(
                "app.log", mode="a", encoding="utf-8"
            ),
        ],
    )
    return logging.getLogger(__name__)```

########################################
Here is my pytest.ini BELOW:
########################################

```ini
#pytest.ini
[pytest]
# Minimum pytest version required for this repo â€” prevents running with older incompatible pytest.
# ensure pytest >= 7.0 is used (helps avoid subtle incompatibilities). 
minversion = 7.0  

# Default CLI options applied to every pytest invocation from this repo.
# - --strict-markers: fail on unknown/typoed @pytest.mark.X decorators (helps catch mis-typed markers).
#   If you enable strict markers, also declare your custom markers below via the `markers` option.
# - -q: quiet mode (limited console output); remove or use -v for verbose output in local debugging.
# - --cov=src: measure coverage for the `src` package (adjust path to your package directory if different).
# - --cov-report=term-missing: show coverage summary in terminal and list missing lines per file.
 # default flags for all runs. 
# TEST Code
addopts = --strict-markers -q --cov=ai_integration --cov=utilities --cov=database --cov=ui --cov=src --cov=main --cov-report=term-missing --cov-report=html 
#addopts = --strict-markers -q --cov=src --cov-report=term-missing 

# By default pytest will look here for tests when run from project root.
# keep tests in `tests/` directory to match this setting. 
testpaths = tests  

# Pattern used to detect test files. Ex: test_example.py, test_foo.py
# explicit discovery pattern; change if your test filenames differ.
python_files = test_*.py   
 # TEST Code
log_cli = true  
 # TEST Code
log_cli_level = INFO  

# Optional: explicitly declare any custom markers used in your suite to make marker usage discoverable
# (useful combined with --strict-markers so typos error out rather than silently being ignored).
# Example:
# markers =
#     slow: marks tests as slow (deselect with '-m "not slow"')
#     gui: marks tests that touch GUI code and may require headless setup
#
# If you use many custom markers, uncomment and list them here. 

```
