5, pady=5, sticky="e")
    degree_level_var = tk.StringVar(value=current_user.get("degree_level", ""))
    degree_level_combo = ttk.Combobox(
        pref_frame, textvariable=degree_level_var, state="readonly", width=45
    )
    degree_level_combo.grid(row=2, column=1, padx=5, pady=5, sticky="w")

    degree_label = ttk.Label(pref_frame, text="Degree:")
    degree_label.grid(row=3, column=0, padx=5, pady=5, sticky="e")
    degree_var = tk.StringVar(value=current_user.get("degree", ""))
    degree_combo = ttk.Combobox(
        pref_frame, textvariable=degree_var, state="readonly", width=45
    )
    degree_combo.grid(row=3, column=1, padx=5, pady=5, sticky="w")

    job_label = ttk.Label(pref_frame, text="Preferred Job:")
    job_label.grid(row=4, column=0, padx=5, pady=5, sticky="e")
    job_var = tk.StringVar(value=current_user.get("job", ""))
    job_combo = ttk.Combobox(
        pref_frame, textvariable=job_var, state="readonly", width=45
    )
    job_combo.grid(row=4, column=1, padx=5, pady=5, sticky="w")

    job_desc_label = ttk.Label(frame, text="Job Description:")
    job_desc_label.pack(pady=(10, 0), anchor="w", padx=20)
    job_desc_text = tk.Text(frame, height=5, wrap="word", width=100)
    job_desc_text.pack(pady=5, padx=20, fill="x")

    college_combo["values"] = [
        "College of Engineering",
        "College of Arts and Sciences",
        "College of Business",
    ]
    degree_level_combo["values"] = ["Undergraduate", "Graduate"]
    degree_combo["values"] = ["B.S. Computer Science", "M.S. Software Engineering"]
    department_combo["values"] = [
        "Computer Science",
        "Information Technology",
        "Software Engineering",
    ]
    job_combo["values"] = [
        "Software Engineer",
        "Data Scientist",
        "AI Specialist",
        "Web Developer",
    ]

    def save_preferences():
        """Saves user preferences (Placeholder will add functionality to save to database)"""
        prefs = {
            "college": college_var.get(),
            "department": department_var.get(),
            "degree_level": degree_level_var.get(),
            "degree": degree_var.get(),
            "job": job_var.get(),
            "job_description": job_desc_text.get("1.0", "end").strip(),
        }
        current_user.update(prefs)
        logger.info(f"User preferences saved: {prefs}")
        messagebox.showinfo("Preferences Saved", "Your preferences have been saved.")

    def clear_preferences():
            """Clears all preference fields"""
            college_var.set("")
            department_var.set("")
            degree_level_var.set("")
            degree_var.set("")
            job_var.set("")
            job_desc_text.delete("1.0", "end")
            logger.info("User cleared all preferences fields.")

            for key in [
                "college",
                "department",
                "degree_level",
                "degree",
                "job",
                "job_description",
        ]:
                current_user[key] = ""
            logger.info("Current user preferences reset in memory.")
            messagebox.showinfo(
            "Preferences Cleared", "All preference fields have been cleared."
        )

    save_button = tk.Button(
        frame, text="Save Preferences", width=20, command=save_preferences
    )
    save_button.pack(pady=20)

    clear_button = tk.Button(
        frame,
        text="Clear Preferences",
        width=20,
        bg="#FF6666",
        command=clear_preferences,
    )
    clear_button.pack(pady=5)


def show_recommendations(frame):
    """Display for Recommendations Page"""
    if not login_status:
        messagebox.showwarning("Access Denied", "Please login to view recommendations.")
        logger.warning("Unauthorized access attempt to Recommendations Page.")
        return
    set_active_button("Recommendations")
    logger.info("Displaying Recommendations Page")
    clear_content(frame)
    header_label = tk.Label(
        frame, text="Course Recommendations", font=("Helvetica", 14)
    )
    header_label.pack(pady=20)

    generate_button = tk.Button(
        frame,
        text="Generate Recommendations",
        width=25,
        command=lambda: generate_recommendations_ui(frame),
    )
    generate_button.pack(pady=10)

    rec_frame = ttk.Frame(frame)
    rec_frame.pack(pady=10, padx=20, fill="both", expand=True)


def parse_recommendations(raw_response):
    """
    Parses the raw AI response (JSON string) into a structured list of course recommendations.

    :param raw_response: str, The raw JSON response from the AI model.
    :return: list of dicts, Each dict contains course details.
    """
    recommendations = []
    try:
        data = json.loads(raw_response)
        logger.debug("Parsed JSON response successfully.")

        if isinstance(data, list):
            for course in data:
                required_keys = [
                    "Course Code",
                    "Course Name",
                    "Rating",
                    "Prerequisites",
                    "Explanation",
                ]
                if all(key in course for key in required_keys):
                    recommendations.append(course)
                else:
                    logger.warning(f"Course data missing required keys: {course}")
        else:
            logger.error("AI response is not a list.")
    except json.JSONDecodeError as jde:
        logger.error(f"JSON decoding failed: {jde}")
    except Exception as e:
        logger.error(f"Error parsing AI recommendations: {e}")
    return recommendations


def display_recommendations_ui(rec_frame, recommendations):
    """Displays the list of recommendations in the given frame with toggleable explanations."""
    clear_content(rec_frame)

    if not recommendations:
        messagebox.showinfo("No Recommendations", "No recommendations available.")
        return

    canvas = tk.Canvas(rec_frame, borderwidth=0, background="#f0f0f0")
    scrollbar = ttk.Scrollbar(rec_frame, orient="vertical", command=canvas.yview)
    scrollable_frame = ttk.Frame(canvas, padding=(10, 10, 10, 10))

    scrollable_frame.bind(
        "<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
    canvas.configure(yscrollcommand=scrollbar.set)

    canvas.pack(side="left", fill="both", expand=True, padx=10, pady=10)
    scrollbar.pack(side="right", fill="y", pady=10)
    rec_frame.pack(fill="both", expand=True)

    for rec in recommendations:
        rec_container = ttk.Frame(
            scrollable_frame, relief="solid", borderwidth=1, padding=(10, 10)
        )
        rec_container.pack(padx=5, pady=5, fill="x", expand=True)

        course_label = ttk.Label(
            rec_container,
            text=f"{rec.get('Course Name', 'N/A')} ({rec.get('Course Code', 'N/A')})",
            font=("Helvetica", 12, "bold"),
            background="#ffffff",
        )
        course_label.pack(anchor="w", padx=5, pady=5)

        units = rec.get("Units", "N/A")
        units_label = ttk.Label(
            rec_container, text=f"Units: {units}", background="#ffffff"
        )
        units_label.pack(anchor="w", padx=5)

        rating = rec.get("Rating", "N/A")
        rating_label = ttk.Label(
            rec_container, text=f"Rating: {rating}/100", background="#ffffff"
        )
        rating_label.pack(anchor="w", padx=5)

        prereqs = rec.get("Prerequisites", "")
        prereq_text = prereqs if prereqs else "None"
        prereq_label = ttk.Label(
            rec_container, text=f"Prerequisites: {prereq_text}", background="#ffffff"
        )
        prereq_label.pack(anchor="w", padx=5, pady=5)

        toggle_btn = ttk.Button(rec_container, text="Show Explanation")
        toggle_btn.pack(anchor="w", padx=5, pady=5)

        explanation = rec.get("Explanation", "No explanation provided.")
        explanation_label = ttk.Label(
            rec_container,
            text=explanation,
            wraplength=800,
            justify="left",
            background="#e6e6e6",
            padding=(5, 5),
        )

        def toggle_explanation(label=explanation_label, button=toggle_btn):
            """Toggle the visibility of the explanation label."""
            if label.winfo_ismapped():
                label.pack_forget()
                button.config(text="Show Explanation")
            else:
                label.pack(anchor="w", padx=5, pady=5)
                button.config(text="Hide Explanation")

        toggle_btn.config(command=toggle_explanation)

        details_btn = ttk.Button(
            rec_container,
            text="View Details",
            command=lambda c=rec: show_course_details(rec_container, c),
        )
        details_btn.pack(anchor="e", padx=5, pady=5)


def generate_recommendations_ui(frame):
    """Generates and displays course recommednations (Placeholder need to add functionality with AI and database)"""
    global current_user

    clear_content(frame)
    set_active_button("Recommendations")
    header_label = tk.Label(
        frame, text="Course Recommendations", font=("Helvetica", 14)
    )
    header_label.pack(pady=20)

    loading_label = tk.Label(
        frame, text="Generating recommendations, please wait...", font=("Helvetica", 12)
    )
    loading_label.pack(pady=10)
    frame.update()

    try:
        required_fields = ["college", "department", "degree_level", "degree", "job"]
        missing_fields = [
            field
            for field in required_fields
            if field not in current_user or not current_user[field]
        ]
        if missing_fields:
            messagebox.showwarning(
                "Incomplete Preferences",
                f"Please complete your preferences before generating recommendations. Missing: {', '.join(missing_fields)}",
            )
            logger.warning(
                f"Cannot generate recommendations, missing preferences: {missing_fields}"
            )
            show_preferences(frame)
            return

        csv_path = os.path.join("database", "courses.csv")
        if not os.path.exists(csv_path):
            raise FileNotFoundError(f"Electives CSV file not found at {csv_path}")

        with open(csv_path, "r", encoding="utf-8") as f:
            csv_text = f.read()
        degree_electives = _parse_degree_electives_csv(csv_text)

        job_name = current_user["job"]
        degree_name = current_user["degree"]
        job_id = 1

        response = get_recommendations_ai(
            job_id=job_id,
            job_name=job_name,
            degree_name=degree_name,
            degree_electives=degree_electives,
        )
        recommendations = parse_recommendations(response)
        if not recommendations:
            messagebox.showerror(
                "AI Error", "Failed to parse recommendations. Please try again."
            )
            logger.error("No recommednations parsed from AI response.")
            return
        rec_frame = frame.winfo_children()[-1]
        clear_content(rec_frame)
        display_recommendations_ui(rec_frame, recommendations)

        """
        rec_data = json.loads(response)
        loading_label.destroy()

        results_frame = ttk.Frame(frame)
        results_frame.pack(pady=10, padx=20, fill="both", expand=True)

        canvas = tk.Canvas(results_frame)
        scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(
                scrollregion=canvas.bbox("all")
            ))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        if isinstance(rec_data, list) and rec_data:
            for course in rec_data:
                title = course.get("Course Name", "N/A")
                desc = course.get("Description", "No description available.")
                units = course.get("Units", "N/A")
                prereqs = ", ".join([course.get(f"Prereq{i}", "") for i in range(1, 4) if course.get(f"Prereq{i}")])
                card = ttk.LabelFrame(scrollable_frame, text=title)
                card.pack(fill="x", pady=5, padx=5)

                info = f"Units: {units}\nPrerequisites: {prereqs}\n\n{desc}"
                tk.Label(card, text=info, justify = "left", wraplength=800, font=("Helvetica", 10, "bold")).pack(anchor="w", padx=10, pady=5)

        else:
           tk.Label(scrollable_frame, text="No recommendations found.", font=("Helvetica", 12)).pack(pady=20)
           logger.info("No recommendations returned from AI module.")
 """
        logger.info("Course recommendations generated and displayed successfully.")
    except Exception as e:
        messagebox.showerror("Error", f"An error occurred: {e}")
        logger.error(f"Error checking user preferences: {e}")
        return

def save_recommendations_to_db(recommendations):
    """Saves Recommendations to the database (Placeholder function)"""
    saved_count = 0


def show_course_details(frame):
    """Display for course details"""
    clear_content(frame)
    tk.Label(frame, text="Course Details Page", font=("Helvetica", 14)).pack(pady=20)


def show_profile(frame):
    """Display for User Profile and Account Settings"""
    logger.info("Displaying Profile Page")
    set_active_button("Profile")
    clear_content(frame)
    global current_user

    profile_header = tk.Label(frame, text="User Profile", font=("Helvetica", 14))
    profile_header.pack(pady=20)

    full_name = f"{current_user.get('first_name', 'N/A')} {current_user.get('last_name', '')}".strip()
    profile_name_label = tk.Label(
        frame, text=f"Name: {full_name}", font=("Helvetica", 12)
    )
    profile_name_label.pack(pady=5)

    profile_email_label = tk.Label(
        frame, text=f"Email: {current_user.get('email', 'N/A')}", font=("Helvetica", 12)
    )
    profile_email_label.pack(pady=5)

    settings_frame = ttk.LabelFrame(frame, text="Account Settings")
    settings_frame.pack(pady=20, fill="x", padx=20)

    def change_password():
        """Changes Password"""
        logger.info("User initiated password change.")
        password_window = tk.Toplevel(frame)
        password_window.title("Change Password")

        current_password_label = ttk.Label(password_window, text="Current Password:")
        current_password_label.pack(pady=10, padx=10, anchor="w")
        current_password_entry = ttk.Entry(password_window, width=30, show="*")
        current_password_entry.pack(pady=5, padx=10, anchor="w")

        new_password_label = ttk.Label(password_window, text="New Password:")
        new_password_label.pack(pady=10, padx=10, anchor="w")
        new_password_entry = ttk.Entry(password_window, width=30, show="*")
        new_password_entry.pack(pady=5, padx=10, anchor="w")

        confirm_new_pw_label = ttk.Label(password_window, text="Confirm New Password:")
        confirm_new_pw_label.pack(pady=10, padx=10, anchor="w")
        confirm_new_pw_entry = ttk.Entry(password_window, width=30, show="*")
        confirm_new_pw_entry.pack(pady=5, padx=10, anchor="w")

        def perform_password_change():
            current_password = current_password_entry.get().strip()
            new_password = new_password_entry.get().strip()
            confirm_password = confirm_new_pw_entry.get().strip()

            conn = get_db_connection()
            cursor = conn.cursor()

            cursor.execute(
                "SELECT password_hash FROM users WHERE email = ?",
                (current_user["email"],),
            )
            row = cursor.fetchone()

            if not row:
                messagebox.showerror(
                    "Error",
                    "User record not found in database.",
                    parent=password_window,
                )
                conn.close()
                return

            stored_hash = row[0]

            if not bcrypt.checkpw(
                current_password.encode("utf-8"), stored_hash.encode("utf-8")
            ):
                messagebox.showerror(
                    "Error", "Current password is incorrect.", parent=password_window
                )
                conn.close()
                return

            if new_password != confirm_password:
                messagebox.showerror(
                    "Error", "New passwords do not match.", parent=password_window
                )
                conn.close()
                return

            if len(new_password) < 8:
                messagebox.showerror(
                    "Error",
                    "Password must be at least 8 characters long.",
                    parent=password_window,
                )
                return

            new_hash = bcrypt.hashpw(
                new_password.encode("utf-8"), bcrypt.gensalt()
            ).decode("utf-8")

            cursor.execute(
                "UPDATE users SET password_hash = ? WHERE email = ?",
                (new_hash, current_user["email"]),
            )
            conn.commit()
            conn.close()

            messagebox.showinfo(
                "Success", "Password changed successfully!", parent=password_window
            )
            logger.info(f"User '{current_user['email']}' changed password.")
            password_window.destroy()

        save_password_button = ttk.Button(
            password_window, text="Save Password", command=perform_password_change
        )
        save_password_button.pack(pady=20)

    change_password_button = ttk.Button(
        settings_frame, text="Change Password", command=change_password
    )
    change_password_button.pack(pady=10, padx=10, fill="x")


def show_help(frame):
    """Display the Help Page"""
    logger.info("Displaying Help Page")
    clear_content(frame)
    set_active_button("Help")

    header_label = ttk.Label(frame, text="Help & Support", font=("Helvetica", 20))
    header_label.pack(pady=20)

    help_frame = ttk.Frame(frame)
    help_frame.pack(pady=10, padx=20, fill="both", expand=True)

    help_text = (
        "Welcome to the Smart Elective Advisor Help Center!\n\n"
        "If you need help navigating the application or have any questions, we've got you covered.\n\n"
        "1. Use Guides: Detailed manuals to help you explore and make the most of the application's features\n\n"
        "2. FAQs: Quick answers to the most common questions from other users.\n\n"
        "3. Contact Support: Need personalized help? Reach out to our support team at support@university.edu\n\n"
    )
    help_label = ttk.Label(
        help_frame,
        text=help_text,
        font=("Helvetica", 14),
        wraplength=800,
        justify="left",
    )
    help_label.pack(pady=10)

    search_label = ttk.Label(
        help_frame, text="Search Help Topics:", font=("Helvetica", 12)
    )
    search_label.pack(pady=5, anchor="w")
    search_entry = ttk.Entry(help_frame, width=50)
    search_entry.pack(pady=5, anchor="w")

    def search_help():
        query = search_entry.get()
        messagebox.showinfo("Coming soon", "coming soon")

    search_button = ttk.Button(help_frame, text="Search", command=search_help)
    search_button.pack(pady=5, anchor="w")

    help_frame.pack_propagate(False)
    spacer = ttk.Frame(help_frame)
    spacer.pack(fill="both", expand=True)
    about_button = ttk.Button(
        help_frame,
        text="About",
        command=lambda: show_about_dialog(frame),
    )
    about_button.pack(pady=10, anchor="e")


def main_test_ui(option: int) -> bool:
    """
    UI test dispatcher:
      option 1 -> launch the real GUI (blocking; user must close window)
      option 2 -> sanity create/destroy root without entering mainloop (fast)
      option 3 -> launch GUI and auto-close after 1 second (useful for CI)
    Returns True on success, False on failure.
    """
    logger.info("main_test_ui: selected option %s", option)

    if option == 1:
        try:
            main_int_ui()
            return True
        except Exception:
            logger.exception("main_test_ui option 1 failed")
            return False

    elif option == 2:
        try:
            root = tk.Tk()
            root.update_idletasks()
            root.destroy()
            logger.info("main_test_ui option 2: sanity create/destroy succeeded")
            return True
        except Exception:
            logger.exception("main_test_ui option 2 failed")
            return False

    elif option == 3:
        try:
            def _run_and_close():
                root = tk.Tk()
                root.title("Smart Elective Advisor (auto-close test)")
                label = tk.Label(root, text="Auto-close test (1s)")
                label.pack(padx=10, pady=10)
                root.after(1000, root.destroy)
                try:
                    root.mainloop()
                except Exception:
                    logger.exception("Exception in auto-close GUI thread")

            t = threading.Thread(target=_run_and_close, daemon=True)
            t.start()
            time.sleep(1.5)
            logger.info("main_test_ui option 3: auto-close GUI test completed")
            return True
        except Exception:
            logger.exception("main_test_ui option 3 failed")
            return False

    else:
        logger.error("main_test_ui: unknown option %s", option)
        return False


if __name__ == "__main__":
    main_test_ui(1)```

########################################
Here is my code for zulu_timestamp.py BELOW:
########################################

```python
# ui/zulu_timestamp.py

from datetime import datetime


def iso_zulu_to_json_parts(ts: str) -> dict:
    """
    Parse an ISO-8601 UTC ('Z') timestamp like 'YYYY-MM-DDTHH:MM:SSZ'
    and return a dict of each component using only the Python stdlib.
    """
    norm = ts.replace("Z", "+00:00")
    dt = datetime.fromisoformat(norm)

    year = f"{dt.year:04d}"
    month = f"{dt.month:02d}"
    day = f"{dt.day:02d}"
    hour = f"{dt.hour:02d}"
    minute = f"{dt.minute:02d}"
    second = f"{dt.second:02d}"

    offset = dt.utcoffset()
    if offset is None:
        utc_offset = "+00:00"
    else:
        total_minutes = int(offset.total_seconds() // 60)
        sign = "+" if total_minutes >= 0 else "-"
        total_minutes = abs(total_minutes)
        utc_offset = f"{sign}{total_minutes // 60:02d}:{total_minutes % 60:02d}"

    return {
        "original": ts,
        "date": f"{year}-{month}-{day}",
        "year": year,
        "month": month,
        "day": day,
        "iso8601_separator": "T",
        "time_UTC": f"{hour}:{minute}:{second}",
        "hour": hour,
        "minute": minute,
        "second": second,
        "timezone_designator": "Z" if ts.endswith("Z") else "",
        "utc_offset": utc_offset,
    }```

########################################
Here is my code for __init__.py BELOW:
########################################

```python
```

########################################
Here is my code for load_env.py BELOW:
########################################

```python
# utilities/load_env.py

import logging
import os
import re
from pathlib import Path
from typing import Optional

from dotenv import find_dotenv, load_dotenv

logger = logging.getLogger(__name__)


def _validate_api_key(key: str) -> bool:
    """
    Conservative validation for the OpenAI API key:
    - must be at least 20 characters (adjust to your provider's expected length)
    - contains at least one alphanumeric character
    """
    if not key:
        return False
    if len(key) < 20:
        return False
    if not re.search(r"[A-Za-z0-9]", key):
        return False
    return True


def load_environment() -> None:
    """
    Load environment variables from .env (if present) and validate required vars.
    Raises ValueError on missing/invalid critical variables.
    """
    logger.info("Loading environment variables.")

    env_path = find_dotenv()
    if env_path:
        load_dotenv(env_path, override=False)
        logger.debug("Loaded .env from %s", env_path)
    else:
        logger.debug(
            ".env file not found; continuing with existing environment variables"
        )

    apikey = os.getenv("OPENAI_API_KEY")
    if not _validate_api_key(apikey or ""):
        logger.error("OPENAI_API_KEY is missing or invalid")
        raise ValueError("OPENAI_API_KEY environment variable missing or invalid")

    logger.info("API Key loaded successfully.")```

########################################
Here is my code for logger_setup.py BELOW:
########################################

```python
# utilities/logger_setup.py

import logging



def setup_logger():
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(asctime)s %(levelname)s %(name)s:%(lineno)d %(message)s",
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler(
                "app.log", mode="a", encoding="utf-8"
            ),
        ],
    )
    return logging.getLogger(__name__)```

########################################
Here is my pytest.ini BELOW:
########################################

```ini
#pytest.ini
[pytest]
# Minimum pytest version required for this repo â€” prevents running with older incompatible pytest.
# ensure pytest >= 7.0 is used (helps avoid subtle incompatibilities). 
minversion = 7.0  

# Default CLI options applied to every pytest invocation from this repo.
# - --strict-markers: fail on unknown/typoed @pytest.mark.X decorators (helps catch mis-typed markers).
#   If you enable strict markers, also declare your custom markers below via the `markers` option.
# - -q: quiet mode (limited console output); remove or use -v for verbose output in local debugging.
# - --cov=src: measure coverage for the `src` package (adjust path to your package directory if different).
# - --cov-report=term-missing: show coverage summary in terminal and list missing lines per file.
 # default flags for all runs. 
# TEST Code
addopts = --strict-markers -q --cov=ai_integration --cov=utilities --cov=database --cov=ui --cov=src --cov=main --cov-report=term-missing --cov-report=html 
#addopts = --strict-markers -q --cov=src --cov-report=term-missing 

# By default pytest will look here for tests when run from project root.
# keep tests in `tests/` directory to match this setting. 
testpaths = tests  

# Pattern used to detect test files. Ex: test_example.py, test_foo.py
# explicit discovery pattern; change if your test filenames differ.
python_files = test_*.py   
 # TEST Code
log_cli = true  
 # TEST Code
log_cli_level = INFO  

# Optional: explicitly declare any custom markers used in your suite to make marker usage discoverable
# (useful combined with --strict-markers so typos error out rather than silently being ignored).
# Example:
# markers =
#     slow: marks tests as slow (deselect with '-m "not slow"')
#     gui: marks tests that touch GUI code and may require headless setup
#
# If you use many custom markers, uncomment and list them here. 

```
